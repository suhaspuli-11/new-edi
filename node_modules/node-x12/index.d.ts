// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   stream

declare module 'node-x12' {
    export * from 'node-x12/dist/src/JSEDINotation';
    export * from 'node-x12/dist/src/X12Element';
    export * from 'node-x12/dist/src/X12FatInterchange';
    export * from 'node-x12/dist/src/X12FunctionalGroup';
    export * from 'node-x12/dist/src/X12Generator';
    export * from 'node-x12/dist/src/X12Interchange';
    export * from 'node-x12/dist/src/X12Parser';
    export * from 'node-x12/dist/src/X12QueryEngine';
    export * from 'node-x12/dist/src/X12Segment';
    export * from 'node-x12/dist/src/X12SegmentHeader';
    export * from 'node-x12/dist/src/X12SerializationOptions';
    export * from 'node-x12/dist/src/X12Transaction';
    export * from 'node-x12/dist/src/X12TransactionMap';
    export * from 'node-x12/dist/src/X12ValidationEngine';
}

declare module 'node-x12/dist/src/JSEDINotation' {
    import { X12SerializationOptions } from 'node-x12/dist/src/X12SerializationOptions';
    export class JSEDINotation {
        constructor(header?: string[], options?: X12SerializationOptions);
        options?: X12SerializationOptions;
        header: string[];
        functionalGroups: JSEDIFunctionalGroup[];
        addFunctionalGroup(header: string[]): JSEDIFunctionalGroup;
    }
    export class JSEDIFunctionalGroup {
        constructor(header?: string[]);
        header: string[];
        transactions: JSEDITransaction[];
        addTransaction(header: string[]): JSEDITransaction;
    }
    export class JSEDITransaction {
        constructor(header?: string[]);
        header: string[];
        segments: JSEDISegment[];
        addSegment(tag: string, elements: string[]): JSEDISegment;
    }
    export class JSEDISegment {
        constructor(tag: string, elements: string[]);
        tag: string;
        elements: string[];
    }
}

declare module 'node-x12/dist/src/X12Element' {
    import { Range } from 'node-x12/dist/src/Positioning';
    export class X12Element {
        /**
          * @description Create an element.
          * @param {string} value - A value for this element.
          */
        constructor(value?: string);
        range: Range;
        value: string;
    }
}

declare module 'node-x12/dist/src/X12FatInterchange' {
    import { JSEDINotation } from 'node-x12/dist/src/JSEDINotation';
    import { X12Interchange } from 'node-x12/dist/src/X12Interchange';
    import { X12SerializationOptions } from 'node-x12/dist/src/X12SerializationOptions';
    export class X12FatInterchange extends Array<X12Interchange> {
            /**
                * @description Create a fat interchange.
                * @param {X12Interchange[] | X12SerializationOptions} [items] - The items for this array or options for this interchange.
                * @param {X12SerializationOptions} [options] - Options for serializing back to EDI.
                */
            constructor(items?: X12Interchange[] | X12SerializationOptions, options?: X12SerializationOptions);
            interchanges: X12Interchange[];
            options: X12SerializationOptions;
            /**
                * @description Serialize fat interchange to EDI string.
                * @param {X12SerializationOptions} [options] - Options to override serializing back to EDI.
                * @returns {string} This fat interchange converted to EDI string.
                */
            toString(options?: X12SerializationOptions): string;
            /**
                * @description Serialize interchange to JS EDI Notation object.
                * @returns {JSEDINotation[]} This fat interchange converted to an array of JS EDI notation.
                */
            toJSEDINotation(): JSEDINotation[];
            /**
                * @description Serialize interchange to JSON object.
                * @returns {object[]} This fat interchange converted to an array of objects.
                */
            toJSON(): object[];
    }
}

declare module 'node-x12/dist/src/X12FunctionalGroup' {
    import { X12Segment } from 'node-x12/dist/src/X12Segment';
    import { X12Transaction } from 'node-x12/dist/src/X12Transaction';
    import { X12SerializationOptions } from 'node-x12/dist/src/X12SerializationOptions';
    export class X12FunctionalGroup {
            /**
                * @description Create a functional group.
                * @param {X12SerializationOptions} [options] - Options for serializing back to EDI.
                */
            constructor(options?: X12SerializationOptions);
            header: X12Segment;
            trailer: X12Segment;
            transactions: X12Transaction[];
            options: X12SerializationOptions;
            /**
                * @description Set a GS header on this functional group.
                * @param {string[]} elements - An array of elements for a GS header.
                */
            setHeader(elements: string[]): void;
            /**
                * @description Add a transaction set to this functional group.
                * @returns {X12Transaction} The transaction which was added to this functional group.
                */
            addTransaction(): X12Transaction;
            /**
                * @description Serialize functional group to EDI string.
                * @param {X12SerializationOptions} [options] - Options for serializing back to EDI.
                * @returns {string} This functional group converted to EDI string.
                */
            toString(options?: X12SerializationOptions): string;
            /**
                * @description Serialize functional group to JSON object.
                * @returns {object} This functional group converted to an object.
                */
            toJSON(): object;
    }
}

declare module 'node-x12/dist/src/X12Generator' {
    import { JSEDINotation } from 'node-x12/dist/src/JSEDINotation';
    import { X12Interchange } from 'node-x12/dist/src/X12Interchange';
    import { X12SerializationOptions } from 'node-x12/dist/src/X12SerializationOptions';
    export class X12Generator {
            /**
                * @description Factory for generating EDI from JS EDI Notation.
                * @param {JSEDINotation} [jsen] - Javascript EDI Notation object to serialize.
                * @param {X12SerializationOptions} [options] - Options for serializing back to EDI.
                */
            constructor(jsen?: JSEDINotation, options?: X12SerializationOptions);
            /**
                * @description Set the JS EDI Notation for this instance.
                * @param {JSEDINotation} [jsen] - Javascript EDI Notation object to serialize.
                */
            setJSEDINotation(jsen: JSEDINotation): void;
            /**
                * @description Get the JS EDI Notation for this instance.
                * @returns {JSEDINotation} The JS EDI Notation for this instance.
                */
            getJSEDINotation(): JSEDINotation;
            /**
                * @description Set the serialization options for this instance.
                * @param {X12SerializationOptions} [options] - Options for serializing back to EDI.
                */
            setOptions(options: X12SerializationOptions): void;
            /**
                * @description Get the serialization options for this instance.
                * @returns {X12SerializationOptions} The serialization options for this instance.
                */
            getOptions(): X12SerializationOptions;
            /**
                * @description Validate the EDI in this instance.
                * @returns {X12Interchange} This instance converted to an interchange.
                */
            validate(): X12Interchange;
            /**
                * @description Serialize the EDI in this instance.
                * @returns {string} This instance converted to an EDI string.
                */
            toString(): string;
    }
}

declare module 'node-x12/dist/src/X12Interchange' {
    import { JSEDINotation } from 'node-x12/dist/src/JSEDINotation';
    import { X12FunctionalGroup } from 'node-x12/dist/src/X12FunctionalGroup';
    import { X12Segment } from 'node-x12/dist/src/X12Segment';
    import { X12SerializationOptions } from 'node-x12/dist/src/X12SerializationOptions';
    export class X12Interchange {
            /**
                * @description Create an interchange.
                * @param {string|X12SerializationOptions} [segmentTerminator] - A character to terminate segments when serializing; or an instance of X12SerializationOptions.
                * @param {string} [elementDelimiter] - A character to separate elements when serializing; only required when segmentTerminator is a character.
                * @param {X12SerializationOptions} [options] - Options for serializing back to EDI.
                */
            constructor(segmentTerminator?: string | X12SerializationOptions, elementDelimiter?: string, options?: X12SerializationOptions);
            header: X12Segment;
            trailer: X12Segment;
            functionalGroups: X12FunctionalGroup[];
            segmentTerminator: string;
            elementDelimiter: string;
            options: X12SerializationOptions;
            /**
                * @description Set an ISA header on this interchange.
                * @param {string[]} elements - An array of elements for an ISA header.
                */
            setHeader(elements: string[]): void;
            /**
                * @description Add a functional group to this interchange.
                * @param {X12SerializationOptions} [options] - Options for serializing back to EDI.
                * @returns {X12FunctionalGroup} The functional group added to this interchange.
                */
            addFunctionalGroup(options?: X12SerializationOptions): X12FunctionalGroup;
            /**
                * @description Serialize interchange to EDI string.
                * @param {X12SerializationOptions} [options] - Options for serializing back to EDI.
                * @returns {string} This interchange converted to an EDI string.
                */
            toString(options?: X12SerializationOptions): string;
            /**
                * @description Serialize interchange to JS EDI Notation object.
                * @returns {JSEDINotation} This interchange converted to JS EDI Notation object.
                */
            toJSEDINotation(): JSEDINotation;
            /**
                * @description Serialize interchange to JSON object.
                * @returns {object} This interchange converted to an object.
                */
            toJSON(): object;
    }
}

declare module 'node-x12/dist/src/X12Parser' {
    import { Transform } from 'stream';
    import { X12Diagnostic } from 'node-x12/dist/src/X12Diagnostic';
    import { X12FatInterchange } from 'node-x12/dist/src/X12FatInterchange';
    import { X12Interchange } from 'node-x12/dist/src/X12Interchange';
    import { X12Segment } from 'node-x12/dist/src/X12Segment';
    import { X12SerializationOptions } from 'node-x12/dist/src/X12SerializationOptions';
    export class X12Parser extends Transform {
            /**
                * @description Factory for parsing EDI into interchange object.
                * @param {boolean|X12SerializationOptions} [strict] - Set true to strictly follow the EDI spec; defaults to false.
                * @param {string|X12SerializationOptions} [encoding] - The encoding to use for this instance when parsing a stream; defaults to UTF-8.
                * @param {X12SerializationOptions} [options] - The options to use when parsing a stream.
                */
            constructor(strict?: boolean | X12SerializationOptions, encoding?: 'ascii' | 'utf8' | X12SerializationOptions, options?: X12SerializationOptions);
            diagnostics: X12Diagnostic[];
            /**
                * @description Parse an EDI document.
                * @param {string} edi - An ASCII or UTF8 string of EDI to parse.
                * @param {X12SerializationOptions} [options] - Options for serializing from EDI.
                * @returns {X12Interchange|X12FatInterchange} An interchange or fat interchange.
                */
            parse(edi: string, options?: X12SerializationOptions): X12Interchange | X12FatInterchange;
            /**
                * @description Method for processing an array of segments into the node-x12 object model; typically used with the finished output of a stream.
                * @param {X12Segment[]} segments - An array of X12Segment objects.
                * @param {X12SerializationOptions} [options] - Options for serializing from EDI.
                * @returns {X12Interchange|X12FatInterchange} An interchange or fat interchange.
                */
            getInterchangeFromSegments(segments: X12Segment[], options?: X12SerializationOptions): X12Interchange | X12FatInterchange;
            /**
                * @description Flush method for Node API Transform stream.
                * @param {Function} callback - Callback to execute when finished.
                */
            _flush(callback: Function): void;
            /**
                * @description Transform method for Node API Transform stream.
                * @param {object} chunk - A chunk of data from the read stream.
                * @param {string} encoding - Chunk enoding.
                * @param {Function} callback - Callback signalling chunk is processed and instance is ready for next chunk.
                */
            _transform(chunk: any, encoding: string, callback: Function): void;
    }
}

declare module 'node-x12/dist/src/X12QueryEngine' {
    import { X12Parser } from 'node-x12/dist/src/X12Parser';
    import { X12Interchange } from 'node-x12/dist/src/X12Interchange';
    import { X12FunctionalGroup } from 'node-x12/dist/src/X12FunctionalGroup';
    import { X12Transaction } from 'node-x12/dist/src/X12Transaction';
    import { X12Segment } from 'node-x12/dist/src/X12Segment';
    import { X12Element } from 'node-x12/dist/src/X12Element';
    export type X12QueryMode = 'strict' | 'loose';
    export class X12QueryEngine {
            /**
                * @description Factory for querying EDI using the node-x12 object model.
                * @param {X12Parser|boolean} [parser] - Pass an external parser or set the strictness of the internal parser.
                * @param {'strict'|'loose'} [mode='strict'] - Sets the mode of the query engine, defaults to classic 'strict'; adds new behavior of 'loose', which will return an empty value for a missing element so long as the segment exists.
                */
            constructor(parser?: X12Parser | boolean, mode?: X12QueryMode);
            /**
                * @description Query all references in an EDI document.
                * @param {string|X12Interchange} rawEdi - An ASCII or UTF8 string of EDI to parse, or an interchange.
                * @param {string} reference - The query string to resolve.
                * @param {string} [defaultValue=null] - A default value to return if result not found.
                * @returns {X12QueryResult[]} An array of results from the EDI document.
                */
            query(rawEdi: string | X12Interchange, reference: string, defaultValue?: string): X12QueryResult[];
            /**
                * @description Query all references in an EDI document and return the first result.
                * @param {string|X12Interchange} rawEdi - An ASCII or UTF8 string of EDI to parse, or an interchange.
                * @param {string} reference - The query string to resolve.
                * @param {string} [defaultValue=null] - A default value to return if result not found.
                * @returns {X12QueryResult} A result from the EDI document.
                */
            querySingle(rawEdi: string | X12Interchange, reference: string, defaultValue?: string): X12QueryResult;
    }
    /**
        * @description A result as resolved by the query engine.
        * @typedef {object} X12QueryResult
        * @property {X12Interchange} interchange
        * @property {X12FunctionalGroup} functionalGroup
        * @property {X12Transaction} transaction
        * @property {X12Segment} segment
        * @property {X12Element} element
        * @property {string} [value=null]
        * @property {Array<string | string[]>} [values=[]]
        */
    export class X12QueryResult {
            constructor(interchange?: X12Interchange, functionalGroup?: X12FunctionalGroup, transaction?: X12Transaction, segment?: X12Segment, element?: X12Element, value?: string);
            interchange: X12Interchange;
            functionalGroup: X12FunctionalGroup;
            transaction: X12Transaction;
            segment: X12Segment;
            element: X12Element;
            value: string;
            values: Array<string | string[]>;
    }
}

declare module 'node-x12/dist/src/X12Segment' {
    import { Range } from 'node-x12/dist/src/Positioning';
    import { X12Element } from 'node-x12/dist/src/X12Element';
    import { X12SerializationOptions } from 'node-x12/dist/src/X12SerializationOptions';
    export class X12Segment {
            /**
                * @description Create a segment.
                * @param {string} tag - The tag for this segment.
                * @param {X12SerializationOptions} [options] - Options for serializing back to EDI.
                */
            constructor(tag?: string, options?: X12SerializationOptions);
            tag: string;
            elements: X12Element[];
            range: Range;
            options: X12SerializationOptions;
            /**
                * @description Set the tag name for the segment if not provided when constructed.
                * @param {string} tag - The tag for this segment.
                */
            setTag(tag: string): void;
            /**
                * @description Set the elements of this segment.
                * @param {string[]} values - An array of element values.
                * @returns {X12Segment} The current instance of X12Segment.
                */
            setElements(values: string[]): X12Segment;
            /**
                * @description Add an element to this segment.
                * @param {string} value - A string value.
                * @returns {X12Element} The element that was added to this segment.
                */
            addElement(value?: string): X12Element;
            /**
                * @description Replace an element at a position in the segment.
                * @param {string} value - A string value.
                * @param {number} segmentPosition - A 1-based number indicating the position in the segment.
                * @returns {X12Element} The new element if successful, or a null if failed.
                */
            replaceElement(value: string, segmentPosition: number): X12Element;
            /**
                * @description Insert an element at a position in the segment.
                * @param {string} value - A string value.
                * @param {number} segmentPosition - A 1-based number indicating the position in the segment.
                * @returns {X12Element} The new element if successful, or a null if failed.
                */
            insertElement(value?: string, segmentPosition?: number): boolean;
            /**
                * @description Remove an element at a position in the segment.
                * @param {number} segmentPosition - A 1-based number indicating the position in the segment.
                * @returns {boolean} True if successful.
                */
            removeElement(segmentPosition: number): boolean;
            /**
                * @description Get the value of an element in this segment.
                * @param {number} segmentPosition - A 1-based number indicating the position in the segment.
                * @param {string} [defaultValue] - A default value to return if there is no element found.
                * @returns {string} If no element is at this position, null or the default value will be returned.
                */
            valueOf(segmentPosition: number, defaultValue?: string): string;
            /**
                * @description Serialize segment to EDI string.
                * @param {X12SerializationOptions} [options] - Options for serializing back to EDI.
                * @returns {string} This segment converted to an EDI string.
                */
            toString(options?: X12SerializationOptions): string;
            /**
                * @description Serialize transaction set to JSON object.
                * @returns {object} This segment converted to an object.
                */
            toJSON(): object;
    }
}

declare module 'node-x12/dist/src/X12SegmentHeader' {
    export interface X12SegmentHeader {
        tag: string;
        trailer?: string;
        layout: any;
    }
    export const ISASegmentHeader: X12SegmentHeader;
    export const GSSegmentHeader: X12SegmentHeader;
    export const STSegmentHeader: X12SegmentHeader;
}

declare module 'node-x12/dist/src/X12SerializationOptions' {
    import { X12SegmentHeader } from 'node-x12/dist/src/X12SegmentHeader';
    export type TxEngine = 'liquidjs' | 'internal';
    /**
        * Class instance wrapper for serialization options.
        */
    export class X12SerializationOptions {
            constructor(options?: X12SerializationOptions);
            elementDelimiter?: string;
            endOfLine?: string;
            format?: boolean;
            segmentTerminator?: string;
            subElementDelimiter?: string;
            repetitionDelimiter?: string;
            segmentHeaders?: X12SegmentHeader[];
            txEngine?: TxEngine;
    }
    /**
        * @description Set default values for any missing X12SerializationOptions in an options object.
        * @param {X12SerializationOptions} [options] - Options for serializing to and from EDI.
        * @returns {X12SerializationOptions} Serialization options with defaults filled in.
        */
    export function defaultSerializationOptions(options?: X12SerializationOptions): X12SerializationOptions;
}

declare module 'node-x12/dist/src/X12Transaction' {
    import { X12Segment } from 'node-x12/dist/src/X12Segment';
    import { X12SerializationOptions } from 'node-x12/dist/src/X12SerializationOptions';
    import type { X12QueryMode } from 'node-x12/dist/src/X12QueryEngine';
    export class X12Transaction {
            /**
                * @description Create a transaction set.
                * @param {X12SerializationOptions} [options] - Options for serializing back to EDI.
                */
            constructor(options?: X12SerializationOptions);
            header: X12Segment;
            trailer: X12Segment;
            segments: X12Segment[];
            options: X12SerializationOptions;
            /**
                * @description Set a ST header on this transaction set.
                * @param {string[]} elements - An array of elements for a ST header.
                */
            setHeader(elements: string[]): void;
            /**
                * @description Add a segment to this transaction set.
                * @param {string} tag - The tag for this segment.
                * @param {string[]} elements - An array of elements for this segment.
                * @returns {X12Segment} The segment added to this transaction set.
                */
            addSegment(tag: string, elements: string[]): X12Segment;
            /**
                * @description Map data from a javascript object to this transaction set. Will use the txEngine property for Liquid support from `this.options` if available.
                * @param {object} input - The input object to create the transaction from.
                * @param {object} map - The javascript object containing keys and querys to resolve.
                * @param {object} [macro] - A macro object to add or override methods for the macro directive; properties 'header' and 'segments' are reserved words.
                */
            fromObject(input: any, map: any, macro?: any): void;
            /**
                * @description Map data from a transaction set to a javascript object.
                * @param {object} map - The javascript object containing keys and querys to resolve.
                * @param {Function|'strict'|'loose'} [helper] - A helper function which will be executed on every resolved query value, or the mode for the query engine.
                * @param {'strict'|'loose'} [mode] - The mode for the query engine when performing the transform.
                * @returns {object} An object containing resolved values mapped to object keys.
                */
            toObject(map: object, helper?: Function | X12QueryMode, mode?: X12QueryMode): object;
            /**
                * @description Serialize transaction set to EDI string.
                * @param {X12SerializationOptions} [options] - Options for serializing back to EDI.
                * @returns {string} This transaction set converted to an EDI string.
                */
            toString(options?: X12SerializationOptions): string;
            /**
                * @description Serialize transaction set to JSON object.
                * @returns {object} This transaction set converted to an object.
                */
            toJSON(): object;
    }
}

declare module 'node-x12/dist/src/X12TransactionMap' {
    import { X12QueryMode } from 'node-x12/dist/src/X12QueryEngine';
    import { X12Transaction } from 'node-x12/dist/src/X12Transaction';
    import { TxEngine } from 'node-x12/dist/src/X12SerializationOptions';
    export class X12TransactionMap {
            /**
                * @description Factory for mapping transaction set data to javascript object map.
                * @param {object} map - The javascript object containing keys and querys to resolve.
                * @param {X12Transaction} [transaction] - A transaction set to map.
                * @param {Function|'liquidjs'|'internal'|'strict'|'loose'} [helper] - A helper function which will be executed on every resolved query value, a macro engine, or mode.
                * @param {'liquidjs'|'internal'|'strict'|'loose'} [txEngine] - A macro engine to use; either 'internal' or 'liquidjs'; defaults to internal for backwords compatibility, or the mode.
                * @param {'strict'|'loose'} [mode='strict'] - The mode for transforming, passed to the query engine, and defaults to 'strict'; may be set to 'loose' for new behavior with missing elements in the dom.
                */
            constructor(map: any, transaction?: X12Transaction, mode?: X12QueryMode);
            constructor(map: any, transaction?: X12Transaction, txEngine?: TxEngine);
            constructor(map: any, transaction?: X12Transaction, txEngine?: TxEngine, mode?: X12QueryMode);
            constructor(map: any, transaction?: X12Transaction, helper?: Function, mode?: X12QueryMode);
            constructor(map: any, transaction?: X12Transaction, helper?: Function, txEngine?: TxEngine);
            constructor(map: any, transaction?: X12Transaction, helper?: Function, txEngine?: TxEngine, mode?: X12QueryMode);
            protected _map: any;
            protected _transaction: X12Transaction;
            protected _object: any;
            protected _mode: X12QueryMode;
            helper: Function;
            txEngine: TxEngine;
            /**
                * @description Set the transaction set to map and optionally a helper function.
                * @param {X12Transaction} transaction - A transaction set to map.
                * @param {Function} helper - A helper function which will be executed on every resolved query value.
                */
            setTransaction(transaction: X12Transaction, helper?: Function): void;
            /**
                * @description Set the transaction set to map and optionally a helper function.
                * @returns {X12Transaction} The transaction from this instance.
                */
            getTransaction(): X12Transaction;
            /**
                * @description Map data from the transaction set to a javascript object.
                * @param {object} [map] - The javascript object containing keys and querys to resolve.
                * @param {Function} [callback] - A callback function which will be passed to the helper function.
                * @returns {object|object[]} The transaction set mapped to an object or an array of objects.
                */
            toObject(map?: any, callback?: Function): any;
            /**
                * @description Map data from a javascript object to the transaction set.
                * @param {object} input - The input object to create the transaction from.
                * @param {object} [map] - The map to associate values from the input to the transaction, or a macro object.
                * @param {object} [macroObj={}] - A macro object to add or override methods for the macro directive; properties 'header' and 'segments' are reserved words.
                * @returns {X12Transaction} The transaction created from the object values.
                */
            fromObject(input: any, map?: any, macroObj?: any): X12Transaction;
    }
}

declare module 'node-x12/dist/src/X12ValidationEngine' {
    export * from 'node-x12/dist/src/X12ValidationEngine/Interfaces';
    export * from 'node-x12/dist/src/X12ValidationEngine/X12ValidationEngine';
    export * from 'node-x12/dist/src/X12ValidationEngine/X12ValidationErrorCode';
    export * from 'node-x12/dist/src/X12ValidationEngine/X12ValidationRule';
}

declare module 'node-x12/dist/src/Positioning' {
    export class Position {
        constructor(line?: number, character?: number);
        line: number;
        character: number;
    }
    export class Range {
        constructor(startLine?: number, startChar?: number, endLine?: number, endChar?: number);
        start: Position;
        end: Position;
    }
}

declare module 'node-x12/dist/src/X12Diagnostic' {
    import { Range } from 'node-x12/dist/src/Positioning';
    export enum X12DiagnosticLevel {
        Info = 0,
        Warning = 1,
        Error = 2
    }
    export class X12Diagnostic {
        constructor(level?: X12DiagnosticLevel, message?: string, range?: Range);
        level: X12DiagnosticLevel;
        message: string;
        range: Range;
    }
}

declare module 'node-x12/dist/src/X12ValidationEngine/Interfaces' {
    import { X12Segment } from 'node-x12/dist/src/X12Segment';
    import { X12SerializationOptions } from 'node-x12/dist/src/X12SerializationOptions';
    export type GroupResponseCode = 'A' | 'E' | 'P' | 'R' | 'M' | 'W' | 'X';
    export type ValidationType = 'element' | 'segment' | 'transaction' | 'group' | 'interchange';
    export interface ValidationEngineOptions {
        acknowledgement?: {
            isa: X12Segment;
            gs: X12Segment;
            options?: X12SerializationOptions;
            handling?: 'reject' | 'note_errors' | 'allow_partial';
        };
        throwError?: boolean;
        ackMap?: any;
    }
    export interface ValidationReport {
        interchange?: {
            header?: ValidationReport;
            trailer?: ValidationReport;
        };
        group?: {
            groupId: string;
            groupNumber: number;
            groupResponse?: GroupResponseCode;
            transactionCount: number;
            responseLevel?: 'reject' | 'note_errors' | 'allow_partial';
            errors: ValidationError[];
        };
        transaction?: {
            transactionId: string;
            transactionNumber: number;
            errors: ValidationError[];
        };
        segment?: {
            tag: string;
            position: number;
            errors: ValidationError[];
        };
        groups?: ValidationReport[];
        transactions?: ValidationReport[];
        segments?: ValidationReport[];
        elements?: ValidationError[];
    }
    export interface ValidationError {
        description: string;
        codeType: ValidationType;
        code: string;
        position?: number;
        dataSample?: string;
    }
}

declare module 'node-x12/dist/src/X12ValidationEngine/X12ValidationEngine' {
    import { X12Segment } from 'node-x12/dist/src/X12Segment';
    import { X12Element } from 'node-x12/dist/src/X12Element';
    import { X12Transaction } from 'node-x12/dist/src/X12Transaction';
    import { X12FunctionalGroup } from 'node-x12/dist/src/X12FunctionalGroup';
    import { X12Interchange } from 'node-x12/dist/src/X12Interchange';
    import { X12SerializationOptions } from 'node-x12/dist/src/X12SerializationOptions';
    import { ValidationEngineOptions, ValidationReport, GroupResponseCode } from 'node-x12/dist/src/X12ValidationEngine/Interfaces';
    import { X12ElementRule, X12SegmentRule, X12TransactionRule, X12GroupRule, X12InterchangeRule } from 'node-x12/dist/src/X12ValidationEngine/X12ValidationRule';
    export class ValidationEngineError extends Error {
        constructor(message: string, report: ValidationReport);
        report: ValidationReport;
    }
    export class X12ValidationEngine {
        constructor(options?: ValidationEngineOptions);
        pass: boolean;
        report?: ValidationReport;
        acknowledgement?: X12Interchange;
        hardErrors?: Error[];
        throwError: boolean;
        assert(actual: X12Element, expected: X12ElementRule): true | ValidationReport;
        assert(actual: X12Segment, expected: X12SegmentRule): true | ValidationReport;
        assert(actual: X12Transaction, expected: X12TransactionRule): true | ValidationReport;
        assert(actual: X12FunctionalGroup, expected: X12GroupRule, groupResponse?: GroupResponseCode): true | ValidationReport;
        assert(actual: X12Interchange, expected: X12InterchangeRule, groupResponse?: GroupResponseCode): true | ValidationReport;
        acknowledge(isa?: X12Segment, gs?: X12Segment, options?: X12SerializationOptions): X12Interchange;
    }
}

declare module 'node-x12/dist/src/X12ValidationEngine/X12ValidationErrorCode' {
    import { ValidationError } from 'node-x12/dist/src/X12ValidationEngine/Interfaces';
    export const X12ValidationErrorCode: Record<string, (...args: any[]) => ValidationError>;
    export function errorLookup(codeType: 'group', code: string, position?: number): ValidationError;
    export function errorLookup(codeType: 'transaction', code: string, position?: number): ValidationError;
    export function errorLookup(codeType: 'segment', code: string, position?: number): ValidationError;
    export function errorLookup(codeType: 'element', code: string, position?: number, dataSample?: string): ValidationError;
}

declare module 'node-x12/dist/src/X12ValidationEngine/X12ValidationRule' {
    import { X12Segment } from 'node-x12/dist/src/X12Segment';
    import { X12Element } from 'node-x12/dist/src/X12Element';
    import { X12Transaction } from 'node-x12/dist/src/X12Transaction';
    import { X12FunctionalGroup } from 'node-x12/dist/src/X12FunctionalGroup';
    import { X12Interchange } from 'node-x12/dist/src/X12Interchange';
    import { ValidationType, ValidationReport } from 'node-x12/dist/src/X12ValidationEngine/Interfaces';
    export class X12ValidationRule {
        constructor(options: X12ValidationRule);
        engine?: RegExp | 'rule' | string;
        ruleType?: ValidationType;
        failureCode?: string;
        assert?(value: any, position?: number): true | ValidationReport;
        toJSON?(): this;
    }
    export class X12InterchangeRule extends X12ValidationRule {
        constructor(options: X12InterchangeRule);
        engine?: 'rule';
        ruleType?: 'interchange';
        group: X12GroupRule;
        header?: X12SegmentRule;
        trailer?: X12SegmentRule;
        assert?(interchange: X12Interchange): true | ValidationReport;
    }
    export class X12GroupRule extends X12ValidationRule {
        constructor(options: X12GroupRule);
        engine?: 'rule';
        ruleType?: 'group';
        transaction: X12TransactionRule;
        header?: X12SegmentRule;
        trailer?: X12SegmentRule;
        assert?(group: X12FunctionalGroup, controlNumber: number): true | ValidationReport;
    }
    export class X12TransactionRule extends X12ValidationRule {
        constructor(options: X12TransactionRule);
        engine?: 'rule';
        ruleType?: 'transaction';
        segments: X12SegmentRule[];
        header?: X12SegmentRule;
        trailer?: X12SegmentRule;
        assert?(transaction: X12Transaction, controlNumber: number): true | ValidationReport;
    }
    export class X12SegmentRule extends X12ValidationRule {
        constructor(options: X12SegmentRule);
        engine?: 'rule';
        ruleType?: 'segment';
        tag: string;
        elements: X12ElementRule[] | 'skip';
        loopStart?: boolean;
        loopEnd?: boolean;
        mandatory?: boolean;
        assert?(segment: X12Segment, position?: number): true | ValidationReport;
    }
    export class X12ElementRule extends X12ValidationRule {
        constructor(options: X12ElementRule);
        engine?: RegExp | 'rule';
        ruleType?: 'element';
        expect?: string;
        allowBlank?: boolean;
        minLength?: number;
        maxLength?: number;
        minMax?: [number, number];
        padLength?: boolean;
        mandatory?: boolean;
        skip?: boolean;
        checkType?: 'date' | 'datelong' | 'dateshort' | 'time' | 'timelong' | 'timeshort' | 'number' | 'decimal' | 'alphanumeric' | 'id' | 'gs01' | 'st01';
        assert?(element: X12Element, position?: number): true | ValidationReport;
    }
}

